# Architectural Guidelines for Reproducible BPM AI Systems

**Призначення документа:**
Цей документ визначає набір архітектурних принципів та правил проєктування для систем прогнозування бізнес-процесів (Predictive Business Process Monitoring).
Його мета — забезпечити **наукову відтворюваність** (reproducibility), **прозорість експериментів** та **стійкість до структурного дрейфу** (structural drift adaptation).

Ці гайдлайни є обов'язковими для реалізації в системі `bpm_prediction`.

---

## Принцип 1: Config-Driven Experimentation (Експеримент як Код)
**Проблема (Gap 2.4.4):** Наукові дослідження часто неможливо відтворити через "зашиті" в код параметри (hardcoded hyperparameters) та приховану логіку препроцесингу.

**Вимога:**
Жоден параметр, що впливає на результат навчання або структуру даних, не повинен міститися в коді Python. Всі параметри виносяться у декларативні конфігураційні файли.

**Правила реалізації:**
1.  **Розділення конфігурацій:**
    * `model.yaml`: Архітектура нейромережі (кількість шарів, розмірність `hidden_dim`, тип агрегації GNN, dropout).
    * `features.yaml`: Визначення вхідних ознак, методи їх нормалізації та джерела (Log vs POKG).
    * `training.yaml`: Гіперпараметри навчання (learning rate, batch size, scheduler, early stopping patience).
2.  **Versioning:** Кожен запуск експерименту повинен зберігати *копію* використаних конфігів разом з артефактами моделі.
3.  **Заборона магії:** Заборонено використовувати "магічні числа" (наприклад, `if duration > 1000`) у коді препроцесингу. Всі порогові значення мають зчитуватися з конфігу.

---

## Принцип 2: Context-Aware Data Fusion (Злиття Контексту)
**Проблема (Gap 2.4.1):** Традиційні підходи розглядають процес як плоску послідовність подій, втрачаючи зв'язки з ресурсами, правилами та паралельними гілками.

**Вимога:**
Система повинна явно моделювати контекст виконання через механізм **Fusion Graph**, об'єднуючи динамічні дані (Instance Graph) зі статичними знаннями (POKG).

**Правила реалізації:**
1.  **Graph-First Approach:** Первинною структурою даних для моделі є граф. Табличні дані (Log DataFrame) є лише проміжним етапом для побудови графа.
2.  **Dynamic Injection:** Вузли графа виконання (IG) повинні динамічно збагачуватися атрибутами з бази знань (Neo4j) під час формування батчу.
    * *Приклад:* Вузол "Task A" отримує ембеддінг ролі "Manager" з POKG, навіть якщо в логу це явно не вказано.
3.  **Explicit Structural Links:** Якщо BPMN-модель визначає зв'язок (наприклад, Gateway XOR), він має бути присутнім у графі для моделі як ребро або атрибут, щоб GNN могла вивчити причинно-наслідковий зв'язок.

---

## Принцип 3: Robustness to Structural Drift (Стійкість до Дрейфу)
**Проблема:** Зміна версії процесу (додавання нових кроків) ламає моделі, навчені на старих логах.

**Вимога:**
Архітектура повинна підтримувати роботу в умовах мульти-версійності, де модель може обробляти події, яких не було в навчальній вибірці, спираючись на граф знань.

**Правила реалізації:**
1.  **Knowledge Decoupling:** Знання про структуру процесу зберігаються окремо від логів — у версіонованому графі POKG ($T$-versioning).
2.  **OOS Masking (Out-of-Scope):** Система повинна мати механізм фільтрації прогнозів. Вихідний шар нейромережі (Logits) повинен множитися на маску допустимих переходів (`AllowMask`), отриману з POKG для *поточної* версії процесу.
3.  **Lazy Adaptation:** При появі нової версії процесу система повинна оновлювати POKG (додавати нові вузли) без зупинки інференс-сервісу.

---

## Принцип 4: Strict Separation of Concerns (Розділення Відповідальності)
**Проблема:** Змішування логіки підготовки даних та навчання моделей ускладнює підтримку та призводить до помилок (Data Leakage).

**Вимога:**
Чітке розмежування шарів обробки даних.

**Правила реалізації:**
1.  **Feature Engineering Layer:** Модуль препроцесингу (`FeaturePreprocessor`) має бути *Stateless* під час інференсу. Він лише застосовує параметри (min/max, vocab), вивчені на етапі `fit()`.
2.  **Model Agnosticism:** Модель GNN не повинна знати про природу даних (BPMN, XES, SQL). Вона приймає на вхід лише абстрактні тензори PyTorch Geometric (`x`, `edge_index`). Вся бізнес-логіка мапінгу залишається у `FusionBuilder`.
3.  **Adapter Pattern:** Для перемикання між науковим режимом (XES) та індустріальним (Camunda SQL) використовуються адаптери, які приводять дані до єдиного внутрішнього інтерфейсу `EventLog`.

---

## Принцип 5: Full Observability & Benchmarking (Повна Спостережуваність)
**Проблема:** Неможливість порівняти результати різних архітектур через різні умови експериментів.

**Вимога:**
Автоматизований збір метрик та артефактів для кожного запуску.

**Правила реалізації:**
1.  **Unified Metrics:** Всі моделі оцінюються за фіксованим набором метрик:
    * *Accuracy / F1* (Global).
    * *Prefix-Length Accuracy* (точність на ранніх vs пізніх етапах).
    * *OOS Rate* (відсоток "галюцинацій" моделі).
2.  **Artifact Tracking:** Використання MLFlow для логування:
    * Вихідних конфігів (YAML).
    * Ваг моделі (.pt).
    * Графіків навчання (Loss curves).
3.  **Standardized Splits:** Розбиття на Train/Val/Test має бути детермінованим (seed-based) і фіксуватися до початку навчання, щоб усі моделі змагалися в рівних умовах.

4. **Ablation Studies (Чисті тести):** Для доведення ефективності шару EPOKG, кожен експеримент має проводитись у двох режимах:
   * **Baseline Mode:** Forward-pass GNN виконується виключно на `Instance Graph (IG)` без залучення нормативних зв'язків з POKG.
   * **Augmented Mode:** Використання повної архітектури `Fusion Graph`. 
   Порівняння цих режимів є обов'язковим для підтвердження наукової новизни (Розділ 4.2 дисертації).
---
## Принцип 6: Dual-System Execution (Goal-Oriented)
**Логіка реалізації:**
1. **The Agent (Local Predictor):** Оптимізує $P(y_{t+1} | IG_t, POKG)$. Працює за принципом максимізації локальної точності.
2. **The Critic (Global Plan):** Використовує вектор макро-плану $z_{plan}^{(\kappa)}$. 
3. **Integration:** Фінальний скоринг проводиться як $S = \text{softmax}(Z_{agent} \odot M_{critic})$, де $M_{critic}$ — маска допустимих переходів графа, що запобігає порушенню регламенту.
---

## Резюме для розробки (Agent Prompt Context)

При написанні коду керуйтеся наступним пріоритетом:
1.  **Конфігурованість** (чи можу я змінити це в YAML?).
2.  **Модульність** (чи можу я замінити GNN на LSTM без переписування препроцесингу?).
3.  **Відтворюваність** (чи отримаю я той самий результат на іншій машині?).
4.  **Продуктивність** (чи працює це швидко?).

Ця ієрархія гарантує, що створене ПЗ буде валідним науковим інструментом.
